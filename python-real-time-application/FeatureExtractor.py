# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
# FEDERAL UNIVERSITY OF UBERLANDIA
# Faculty of Electrical Engineering
# Biomedical Engineering Lab
# ------------------------------------------------------------------------------
# Author: Italo Gustavo Sampaio Fernandes
# Contact: italogsfernandes@gmail.com
# Git: www.github.com/italogsfernandes
# ------------------------------------------------------------------------------
# Description:
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Processing:
import numpy as np
import pandas as pd
from feature_extractor import *
# ------------------------------------------------------------------------------

class EMGProcessing:
    def __init__(self):
        """
        Routines for processing a emg raw data.
        Pre procesing:
        1. 3 Hz Highpass cut-off frequency - Removes the offset generated by a DC signal
        2. 50Hz or 60Hz band stop filter
        3. Envelope with a 10Hz filter
        """
        self.fs = 1000

        #########################
        # High Pass Filter
        #########################
        self.high_pass_mva_window_size = 100 # 3.2 Hz
        self.high_pass_window = {
        "CH1": np.zeros(self.high_pass_mva_window_size, dtype=np.float64),
        "CH2": np.zeros(self.high_pass_mva_window_size, dtype=np.float64),
        "CH3": np.zeros(self.high_pass_mva_window_size, dtype=np.float64),
        "CH4": np.zeros(self.high_pass_mva_window_size, dtype=np.float64),
        }

        #########################
        # 50Hz Band Stop Filter
        #########################
        self.low_pass_55hz_mva_window_size = 6 # 54Hz
        self.high_pass_45hz_mva_window_size = 7 # 46Hz
        self.low_pass_55hz_window = {
        "CH1": np.zeros(self.low_pass_55hz_mva_window_size, dtype=np.float64),
        "CH2": np.zeros(self.low_pass_55hz_mva_window_size, dtype=np.float64),
        "CH3": np.zeros(self.low_pass_55hz_mva_window_size, dtype=np.float64),
        "CH4": np.zeros(self.low_pass_55hz_mva_window_size, dtype=np.float64),
        }
        self.high_pass_45hz_window = {
        "CH1": np.zeros(self.high_pass_45hz_mva_window_size, dtype=np.float64),
        "CH2": np.zeros(self.high_pass_45hz_mva_window_size, dtype=np.float64),
        "CH3": np.zeros(self.high_pass_45hz_mva_window_size, dtype=np.float64),
        "CH4": np.zeros(self.high_pass_45hz_mva_window_size, dtype=np.float64),
        }

        #########################
        # Features Extraction
        #########################
        self.features_window_size = 200
        self.features_window_index = 0
        self.features_window_overlap = 20 # 10% of 200
        self.features_window = {
        "CH1": np.zeros(self.features_window_size, dtype=np.float64),
        "CH2": np.zeros(self.features_window_size, dtype=np.float64),
        "CH3": np.zeros(self.features_window_size, dtype=np.float64),
        "CH4": np.zeros(self.features_window_size, dtype=np.float64),
        }

        self.ch1_features = {}
        self.ch2_features = {}
        self.ch3_features = {}
        self.ch4_features = {}

        self.features_division_factors = [0.3, 100.0, 0.2, 0.9, 55.0, 150.0]

    def do_high_pass_window(self, values_array):
        """ Creating windows for pre processing
        """
        self.high_pass_window['CH1'][:-1] = self.high_pass_window['CH1'][1:]
        self.high_pass_window['CH1'][-1] = values_array[0]

        self.high_pass_window['CH2'][:-1] = self.high_pass_window['CH2'][1:]
        self.high_pass_window['CH2'][-1] = values_array[1]

        self.high_pass_window['CH3'][:-1] = self.high_pass_window['CH3'][1:]
        self.high_pass_window['CH3'][-1] = values_array[2]

        self.high_pass_window['CH4'][:-1] = self.high_pass_window['CH4'][1:]
        self.high_pass_window['CH4'][-1] = values_array[3]

        values_array[0] = values_array[0] - np.mean(self.high_pass_window['CH1'])
        values_array[1] = values_array[1] - np.mean(self.high_pass_window['CH2'])
        values_array[2] = values_array[2] - np.mean(self.high_pass_window['CH3'])
        values_array[3] = values_array[3] - np.mean(self.high_pass_window['CH4'])

    def do_stop_band_window(self, values_array):
        self.high_pass_45hz_window['CH1'][:-1] = self.high_pass_45hz_window['CH1'][1:]
        self.high_pass_45hz_window['CH1'][-1] = values_array[0]

        self.high_pass_45hz_window['CH2'][:-1] = self.high_pass_45hz_window['CH2'][1:]
        self.high_pass_45hz_window['CH2'][-1] = values_array[1]

        self.high_pass_45hz_window['CH3'][:-1] = self.high_pass_45hz_window['CH3'][1:]
        self.high_pass_45hz_window['CH3'][-1] = values_array[2]

        self.high_pass_45hz_window['CH4'][:-1] = self.high_pass_45hz_window['CH4'][1:]
        self.high_pass_45hz_window['CH4'][-1] = values_array[3]

        higher_freqs = np.zeros(4, dtype=np.float64)
        higher_freqs = values_array[0] - np.mean(self.high_pass_45hz_window['CH1'])
        higher_freqs = values_array[1] - np.mean(self.high_pass_45hz_window['CH2'])
        higher_freqs = values_array[2] - np.mean(self.high_pass_45hz_window['CH3'])
        higher_freqs = values_array[3] - np.mean(self.high_pass_45hz_window['CH4'])

        self.low_pass_55hz_window['CH1'][:-1] = self.low_pass_55hz_window['CH1'][1:]
        self.low_pass_55hz_window['CH1'][-1] = higher_freqs[0]

        self.low_pass_55hz_window['CH2'][:-1] = self.low_pass_55hz_window['CH2'][1:]
        self.low_pass_55hz_window['CH2'][-1] = higher_freqs[1]

        self.low_pass_55hz_window['CH3'][:-1] = self.low_pass_55hz_window['CH3'][1:]
        self.low_pass_55hz_window['CH3'][-1] = higher_freqs[2]

        self.low_pass_55hz_window['CH4'][:-1] = self.low_pass_55hz_window['CH4'][1:]
        self.low_pass_55hz_window['CH4'][-1] = higher_freqs[3]

        stop_freqs = np.zeros(4, dtype=np.float64)
        stop_freqs = np.mean(self.low_pass_55hz_window['CH1'])
        stop_freqs = np.mean(self.low_pass_55hz_window['CH2'])
        stop_freqs = np.mean(self.low_pass_55hz_window['CH3'])
        stop_freqs = np.mean(self.low_pass_55hz_window['CH4'])

        values_array = values_array - stop_freqs

    def do_pre_processing(self, values_array):
        self.do_high_pass_window(values_array)
        self.do_stop_band_window(values_array)

    def add_to_features_window(self, values_array):
        ####################################################
        # Creating windows for extraction of features
        #BUG: I don't know if this will work, but I hope so. I'm still have to test it
        # Adding values to window
        self.features_window['CH1'][self.features_window_index] = values_array[0]
        self.features_window['CH2'][self.features_window_index] = values_array[1]
        self.features_window['CH3'][self.features_window_index] = values_array[2]
        self.features_window['CH4'][self.features_window_index] = values_array[3]
        #
        # 0 1 2 3 4 5 6 7 8 9 10
        # 0 1 2 3 4
        #         4 5 6 7
        #               7 8 9 1
        # incrementing index
        self.features_window_index = self.features_window_index + 1
        if self.features_window_index >= self.features_window_size:
            self.features_window_index = self.features_window_overlap
            self.features_window['CH1'][:self.features_window_overlap] = self.features_window['CH1'][-self.features_window_overlap:]
            self.features_window['CH2'][:self.features_window_overlap] = self.features_window['CH2'][-self.features_window_overlap:]
            self.features_window['CH3'][:self.features_window_overlap] = self.features_window['CH3'][-self.features_window_overlap:]
            self.features_window['CH4'][:self.features_window_overlap] = self.features_window['CH4'][-self.features_window_overlap:]
        ####################################################

        ####################################################
        # Extracting features
        if self.features_window_index == self.features_window_overlap:
            # if I had completed a window and i'm ready to start the next one
            self.apply_feature_extraction()
            self.send_features_to_plot()
        ####################################################

    ####################################################
    # Sending data to chart
    if self.plotHandler.is_enabled:
        ####################################################
        # Applying some adjusts to allow a good plot
        for n in range(4):
            self.emg_values[n] = self.emg_values[n] + n
        ####################################################
        self.plotHandler.lines[0].buffer.put(self.emg_values[0])
        self.plotHandler.lines[1].buffer.put(self.emg_values[1])
        self.plotHandler.lines[2].buffer.put(self.emg_values[2])
        self.plotHandler.lines[3].buffer.put(self.emg_values[3])
    ####################################################
