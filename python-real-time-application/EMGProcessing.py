# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
# FEDERAL UNIVERSITY OF UBERLANDIA
# Faculty of Electrical Engineering
# ------------------------------------------------------------------------------
# Author: Italo Gustavo Sampaio Fernandes
# Contact: italogsfernandes@gmail.com
# Git: www.github.com/italogsfernandes
# ------------------------------------------------------------------------------
# Description:
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Processing:
import numpy as np
import pandas as pd
from feature_extractor import *
# ------------------------------------------------------------------------------

class EMGProcessing:
    def __init__(self):
        """
        Routines for processing a emg raw data.
        Pre procesing:
        1. 3 Hz Highpass cut-off frequency - Removes the offset generated by a DC signal
        2. 50Hz or 60Hz band stop filter
        3. Envelope with a 10Hz filter
        """
        self.fs = 1000

        #########################
        # High Pass Filter
        #########################
        self.high_pass_mva_window_size = 100 # 3.2 Hz
        self.high_pass_window = {
        "CH1": np.zeros(self.high_pass_mva_window_size, dtype=np.float64),
        "CH2": np.zeros(self.high_pass_mva_window_size, dtype=np.float64),
        "CH3": np.zeros(self.high_pass_mva_window_size, dtype=np.float64),
        "CH4": np.zeros(self.high_pass_mva_window_size, dtype=np.float64),
        }

        #########################
        # 50Hz Band Stop Filter
        #########################
        self.low_pass_55hz_mva_window_size = 6 # 54Hz
        self.high_pass_45hz_mva_window_size = 7 # 46Hz
        self.low_pass_55hz_window = {
        "CH1": np.zeros(self.low_pass_55hz_mva_window_size, dtype=np.float64),
        "CH2": np.zeros(self.low_pass_55hz_mva_window_size, dtype=np.float64),
        "CH3": np.zeros(self.low_pass_55hz_mva_window_size, dtype=np.float64),
        "CH4": np.zeros(self.low_pass_55hz_mva_window_size, dtype=np.float64),
        }
        self.high_pass_45hz_window = {
        "CH1": np.zeros(self.high_pass_45hz_mva_window_size, dtype=np.float64),
        "CH2": np.zeros(self.high_pass_45hz_mva_window_size, dtype=np.float64),
        "CH3": np.zeros(self.high_pass_45hz_mva_window_size, dtype=np.float64),
        "CH4": np.zeros(self.high_pass_45hz_mva_window_size, dtype=np.float64),
        }

        #########################
        # Features Extraction
        #########################
        self.features_window_size = 200
        self.features_window_index = 0
        self.features_window_overlap = 20 # 10% of 200
        self.features_window = {
        "CH1": np.zeros(self.features_window_size, dtype=np.float64),
        "CH2": np.zeros(self.features_window_size, dtype=np.float64),
        "CH3": np.zeros(self.features_window_size, dtype=np.float64),
        "CH4": np.zeros(self.features_window_size, dtype=np.float64),
        }

        self.ch1_features = {}
        self.ch2_features = {}
        self.ch3_features = {}
        self.ch4_features = {}

        self.features_division_factors = [0.3, 100.0, 0.2, 0.9, 55.0, 150.0]

    def do_high_pass_filtering(self, values_array):
        """ Creating windows for pre processing
        """
        self.high_pass_window['CH1'][:-1] = self.high_pass_window['CH1'][1:]
        self.high_pass_window['CH1'][-1] = values_array[0]

        self.high_pass_window['CH2'][:-1] = self.high_pass_window['CH2'][1:]
        self.high_pass_window['CH2'][-1] = values_array[1]

        self.high_pass_window['CH3'][:-1] = self.high_pass_window['CH3'][1:]
        self.high_pass_window['CH3'][-1] = values_array[2]

        self.high_pass_window['CH4'][:-1] = self.high_pass_window['CH4'][1:]
        self.high_pass_window['CH4'][-1] = values_array[3]

        values_array[0] = values_array[0] - np.mean(self.high_pass_window['CH1'])
        values_array[1] = values_array[1] - np.mean(self.high_pass_window['CH2'])
        values_array[2] = values_array[2] - np.mean(self.high_pass_window['CH3'])
        values_array[3] = values_array[3] - np.mean(self.high_pass_window['CH4'])

    def do_stop_band_filtering(self, values_array):
        self.high_pass_45hz_window['CH1'][:-1] = self.high_pass_45hz_window['CH1'][1:]
        self.high_pass_45hz_window['CH1'][-1] = values_array[0]

        self.high_pass_45hz_window['CH2'][:-1] = self.high_pass_45hz_window['CH2'][1:]
        self.high_pass_45hz_window['CH2'][-1] = values_array[1]

        self.high_pass_45hz_window['CH3'][:-1] = self.high_pass_45hz_window['CH3'][1:]
        self.high_pass_45hz_window['CH3'][-1] = values_array[2]

        self.high_pass_45hz_window['CH4'][:-1] = self.high_pass_45hz_window['CH4'][1:]
        self.high_pass_45hz_window['CH4'][-1] = values_array[3]

        higher_freqs = np.zeros(4, dtype=np.float64)
        higher_freqs = values_array[0] - np.mean(self.high_pass_45hz_window['CH1'])
        higher_freqs = values_array[1] - np.mean(self.high_pass_45hz_window['CH2'])
        higher_freqs = values_array[2] - np.mean(self.high_pass_45hz_window['CH3'])
        higher_freqs = values_array[3] - np.mean(self.high_pass_45hz_window['CH4'])

        self.low_pass_55hz_window['CH1'][:-1] = self.low_pass_55hz_window['CH1'][1:]
        self.low_pass_55hz_window['CH1'][-1] = higher_freqs[0]

        self.low_pass_55hz_window['CH2'][:-1] = self.low_pass_55hz_window['CH2'][1:]
        self.low_pass_55hz_window['CH2'][-1] = higher_freqs[1]

        self.low_pass_55hz_window['CH3'][:-1] = self.low_pass_55hz_window['CH3'][1:]
        self.low_pass_55hz_window['CH3'][-1] = higher_freqs[2]

        self.low_pass_55hz_window['CH4'][:-1] = self.low_pass_55hz_window['CH4'][1:]
        self.low_pass_55hz_window['CH4'][-1] = higher_freqs[3]

        stop_freqs = np.zeros(4, dtype=np.float64)
        stop_freqs = np.mean(self.low_pass_55hz_window['CH1'])
        stop_freqs = np.mean(self.low_pass_55hz_window['CH2'])
        stop_freqs = np.mean(self.low_pass_55hz_window['CH3'])
        stop_freqs = np.mean(self.low_pass_55hz_window['CH4'])

        values_array = values_array - stop_freqs

    def do_pre_processing(self, values_array):
        self.do_high_pass_window(values_array)
        self.do_stop_band_window(values_array)

    def add_to_features_window(self, values_array):
        ####################################################
        # Creating windows for extraction of features
        #BUG: I don't know if this will work, but I hope so. I'm still have to test it
        # Adding values to window
        self.features_window['CH1'][self.features_window_index] = values_array[0]
        self.features_window['CH2'][self.features_window_index] = values_array[1]
        self.features_window['CH3'][self.features_window_index] = values_array[2]
        self.features_window['CH4'][self.features_window_index] = values_array[3]
        #
        # 0 1 2 3 4 5 6 7 8 9 10
        # 0 1 2 3 4
        #         4 5 6 7
        #               7 8 9 1
        # incrementing index
        self.features_window_index = self.features_window_index + 1
        if self.features_window_index >= self.features_window_size:
            self.features_window_index = self.features_window_overlap
            self.features_window['CH1'][:self.features_window_overlap] = self.features_window['CH1'][-self.features_window_overlap:]
            self.features_window['CH2'][:self.features_window_overlap] = self.features_window['CH2'][-self.features_window_overlap:]
            self.features_window['CH3'][:self.features_window_overlap] = self.features_window['CH3'][-self.features_window_overlap:]
            self.features_window['CH4'][:self.features_window_overlap] = self.features_window['CH4'][-self.features_window_overlap:]
        ####################################################

        ####################################################
        # Extracting features
        if self.features_window_index == self.features_window_overlap:
            # if I had completed a window and i'm ready to start the next one
            self.do_features_extraction()
            #self.call_when_features_window_is_full()
        ####################################################

    def do_features_extraction(self):
        self.ch1_features = get_features(features_window['CH1'])
        self.ch2_features = get_features(features_window['CH2'])
        self.ch3_features = get_features(features_window['CH3'])
        self.ch4_features = get_features(features_window['CH4'])

    def do_offline_pre_processing(self, emg_channels, emg_out):
        emg_pre_processed = np.zeros(emg_channels.shape)
        for ch in range(4):
            emg_no_offset = do_high_pass_mva(emg_channels[:,ch],
             self.high_pass_mva_window_size)
            emg_pre_processed[:, ch] = do_band_stop_mva(emg_no_offset,
             self.high_pass_45hz_mva_window_size,
             self.low_pass_55hz_mva_window_size)
        return emg_pre_processed

    def do_offline_features_extraction(self, emg_pre_processed):
        for n in range(len(emg_pre_processed)):
            self.add_to_features_window(emg_pre_processed[n,:])

    def offline_write_to_file_operation(self, file_name):
        pass

    def do_offline_routine(self, file_name):
        """
        Open file
        Read info (tell if file is too big)
        Close file
        Open output file
        Write header
        write
        """
        #########################
        # Openning File
        #########################
        self.file_obj = open(file_name, mode='r')
        self.file_obj = open(output_file_name, mode='r')
        #########################
        # Writing Header
        #########################
        output_file.write("rms0,rms1,rms2,rms3,")
        output_file.write("zc0,zc1,zc2,zc3,")
        output_file.write("mav0,mav1,mav2,mav3,")
        output_file.write("var0,var1,var2,var3,")
        output_file.write("wl0,wl1,wl2,wl3,")
        output_file.write("ssc0,ssc1,ssc2,ssc3,")
        output_file.write("output\n")
