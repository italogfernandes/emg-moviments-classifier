#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu May 17 16:06:46 2018

@author: italo
"""
#%% Importing the libraries
import pandas as pd # reading files
import numpy as np # handling numerical data
import matplotlib.pyplot as plt # Plotting
from scipy import signal

###############################
#%% Adding the path to datasets
###############################

# Description of the analysed movements:
# Movement Number - Movement Name
# 1 -> Supinar
# 2 -> Pronar
# 3 -> Pinçar
# 4 -> Fechar
# 5 -> Estender
# 6 -> Flexionar
# This should be the output of the classifier. It should classify each moviment
# in one of this classes.
HAND_MOVIMENTS_NAMES = ["Supinar", "Pronar", "Pinçar", "Fechar", "Estender", "Flexionar"]

#########################
#%% Importing the dataset
#########################

# The file name refering to the folder where this script is located
#   - emg-movements-classifier
#       - datasets
#           - coletas
#               - Eber
#               - LH
#               - Miguel... etc
#       - python-hand_moviments-classifier
#           - app_procedimentos
#               - app_procedures.py
file_name = '../../datasets/coletas/Eber/Eber11-Final.txt'

# Opening a file and reading it to a dataFrame object
# sep means separator, the files have no headers
# After reading it, we add the names of each column in the dataset.
# At end, we select the 4 channels as a numpy vector and we save it in
# emg_channels.
# The trigger is saved in emg_trigger.
dataset = pd.read_table(file_name, sep=';', header=None)
dataset.columns = 'CH1 CH2 CH3 CH4 Trigger None'.split()
emg_channels = dataset.iloc[:, :-2].values
emg_trigger = dataset.iloc[:, -2].values

# Here we do the same for obtaining a numpy vector with the movements
# executed in each peek of the trigger.
# targets contains the moviments as a number from 1 to 6
# and targets_str as a string(name)
file_name_targets = '../../datasets/coletas/Eber/Eber11-Resposta.txt'
targets = pd.read_table(file_name_targets, header=None)
targets = targets.iloc[:, :].values.ravel()
targets_str = []
for target in targets:
    targets_str.append(HAND_MOVIMENTS_NAMES[target-1])

#####################
#%% Signal constants
#####################

# The empirical delay time between the signal saying to execute a movement and
# the start of some movement by the volunteer.
# We guess a time of 250ms, this means 500 data points at a sampling frequency
# of 2 kHz
# This s a dalay time in the TRIGGER necessary to sync the TRIGGER with the SIGNAL
delay_trigger = 500 # amount of points to delay
fs = 2000  # Sampling frequency in Hz

#########################
#%% Correcting the triger
#########################

# representation of why there are the necessity of syncing the signals
# Before correction:
#     emg signal: __________. .||||||||-.._____________
#                            ''||||||||-''
# trigger signal:       ________________
#                 _____|               |_____________
#
# After Correction:
#     emg signal: __________. .||||||||-.._____________
#                            ''||||||||-''
# trigger signal:           ________________
#                 _________|               |_____________
#

# append concatenates some values in a array.
# Here we insert a array of zeros at the beggining of the trigger
# objectiving to deslocate the signal
# We also exclude the last 'delay_trigger' points of the signal
# to garant that the new array will have the same size of the emg_trigger
emg_trigger_corrected = np.append(arr = np.zeros(delay_trigger),
                                  values = emg_trigger[:-delay_trigger])

###############################
#%% Optional: Plotting the data
###############################

# Here we use the matplotlib library to plot a small window of the signal
# And verify if everything is all right

fig = plt.figure()
axes = [None for i in range(4)]
for i in range(4):
    axes[i] = plt.subplot(4,1,i+1)
    plt.plot(emg_channels[12000:80000,i])
    plt.plot(emg_trigger[12000:80000]*100)
    plt.title('Ch ' + str(i+1))
    plt.ylim((-1000,1000))
    plt.grid()

axes[0].get_shared_x_axes().join(axes[0],axes[1],axes[2],axes[3])
axes[0].get_shared_y_axes().join(axes[0],axes[1],axes[2],axes[3])
axes[0].set_xticklabels([])
axes[1].set_xticklabels([])
axes[2].set_xticklabels([])
plt.show()

#########################################
#%% Filtering - Pre processing the signal
#########################################

# NOTE: We can change this filter settings, which filters we want to pass, etc
# This is in that way for no raison, only beacause it worked when I tested, but
# I don't know how to explai why did I select this filters etc.

# Paramaters for the filters design
Fnotch = 60.0  # Frequency to remove with NOTCH filter - 60Hz
Fpa = 10.0 # Highpass cut-off frequency - Removes the offset generated by a DC signal
Fpb = 20.0 # Lowpass cut-off frequency - Smooths the signal
Q = 1  # Quality factor of NOTCH filter

# Normalized frequency
Wnotch = Fnotch/(fs/2) # For the notch filter
Wpb = Fpb/(fs/2) # For the Lowpass filter
Wpa = Fpa/(fs/2) # For the highpass filter

# Filters design
b1, a1 = signal.iirnotch(Wnotch, Q) # Design notch filter - Fc = 60Hz
b2, a2 = signal.butter(2, Wpa, 'highpass') # Design butter filter - Fc = 10Hz
b3, a3 = signal.butter(4, Wpb, 'lowpass') # Design butter filter - Fc = 20Hz

#######################
#%% Applying the filters
#######################

# Applying Highpass filter for removing DC signals
emg_filtered_dc = np.zeros(emg_channels.shape)
for ch in range(4): # for each emg channel ...
    emg_filtered_dc[:,ch] = signal.filtfilt(b2, a2, emg_channels[:, ch])

# Applying Notch filter for removing 60Hz interference
emg_filtered_60hz = np.zeros(emg_channels.shape)
for ch in range(4):
    emg_filtered_60hz[:,ch] = signal.filtfilt(b1, a1, emg_filtered_dc[:, ch])

# Retifying the filtered signal
emg_retificado = np.abs(emg_filtered_60hz)

# low-pass filtering the retified signal
emg_smooth = np.zeros(emg_channels.shape)
for ch in range(4):
    emg_smooth[:, ch] = signal.filtfilt(b3, a3, emg_retificado[:, ch])

#################################
#%% Optional: Testing the filters
#################################

# Uncomment which signal do you want to see to verify if it seems to be
# well filtered
plt.subplot(2,1,1)
plt.plot(emg_channels[12000:80000,0])
plt.grid()
plt.subplot(2,1,2)
#plt.plot(emg_filtered_dc[12000:80000,0])
#plt.plot(emg_filtered_60hz[12000:80000,0])
#plt.plot(emg_retificado[12000:80000,0])
plt.plot(emg_smooth[12000:80000,0])
plt.grid()
plt.show()

#####################
#%% Contraction sites
#####################

# Detects the start and end of the contractions by comparing the trigger signal
contractions_onsets = []
contractions_offsets = []
for i in range(1,emg_channels.shape[0]):
    # when the trigger goes up 0 -> 1
    if emg_trigger_corrected[i-1] < 1 and emg_trigger_corrected[i] >= 1:
        contractions_onsets.append(i)
        # uncomment next line if you want a fixed window length of 500 points
        # contractions_offsets.append(i+500)
        # and comment the next 2 lines...
    # when the trigger goes down 1 -> 0
    if emg_trigger_corrected[i-1] > 1 and emg_trigger_corrected[i] <= 1:
        contractions_offsets.append(i)

######################
#%% Feature Extraction
######################

# Below are the 6 features to extract
rms = np.zeros((len(targets), 4), dtype=float) # root mean square (RMS)
zc = np.zeros((len(targets), 4), dtype=float) # zero crossing (ZC)
mav = np.zeros((len(targets), 4), dtype=float) # mean absolute value (MAV)
var = np.zeros((len(targets), 4), dtype=float) # variance (VAR)
wl = np.zeros((len(targets), 4), dtype=float) # waveform length (WL)
ssc = np.zeros((len(targets), 4), dtype=float) # slope sign changes (SSC)

##############
#%% Extracting
##############

# For each movement (each contraction)
for i in range(len(targets)):
    for ch in range(4):
        # RMS
        rms[i,ch] = np.sqrt(np.mean(np.square(
           emg_filtered_60hz[contractions_onsets[i]:contractions_offsets[i],ch]
           )))
        # ZC
        s3= np.sign(
         emg_filtered_60hz[contractions_onsets[i]:contractions_offsets[i],ch])
        s3[s3==0] = -1     # replace zeros with -1
        zc[i,ch] = (np.where(np.diff(s3)))[0].shape[0]
        # MAV
        mav[i, ch] = np.mean(np.abs(
                emg_retificado[contractions_onsets[i]:contractions_offsets[i],ch]
                ))
        # VAR
        var[i, ch] = np.var(
                emg_filtered_60hz[contractions_onsets[i]:contractions_offsets[i],ch]
                )
        # WL
        wl[i, ch] = np.sum(np.abs(np.diff(
                emg_filtered_60hz[contractions_onsets[i]:contractions_offsets[i],ch]
                )))
        # SSC
        ssc[i, ch] = np.where(np.diff(np.sign(np.diff(
                emg_filtered_60hz[contractions_onsets[i]:contractions_offsets[i],ch]
                ))))[0].shape[0]

# Detailled Description:
#    RMS:
#        sqrt(mean(square(vetor)))
#    ZC:
#             a = [ 1,  2,  1,  1, -3, -4,  7,  8,  9, 10, -2,  1, -3,  5,  6,  7,-10]
#        sign() = [ 1,  1,  1,  1, -1, -1,  1,  1,  1,  1, -1,  1, -1,  1,  1,  1, -1]
#        diff() =     [ 0,  0,  0, -2,  0,  2,  0,  0,  0, -2,  2, -2,  2,  0,  0, -2]
#        where() = (array([ 3,  5,  9, 10, 11, 12, 15]),)
#        where()[0].shape[0] = 7
#    The number of zero crossing should be 7, but because sign()
#    returns 0 if 0 is passed, 1 for positive, and -1 for negative values,
#    diff() will count the transition containing zero twice.
#
#   SSC:
#       It uses diff to derivate the signal and obtain the slope
#       So it verifies how many times the slope has changed from a positive
#       number to a negative one.
#       Try uncommenting the next lines and verify:
#        ttt = np.linspace(0,1,1000)
#        xxx = np.sin(2*np.pi*10*ttt) +  0.8*np.sin(2*np.pi*15*ttt) + 0.2*np.sin(2*np.pi*1*ttt)
#
#        ssc_ = np.diff(np.sign(np.diff(xxx)))
#        ssc_ = np.append(ssc_, [0,0])
#        plt.plot(ttt,xxx)
#        plt.plot(ttt,ssc_)
#        ssc_ = np.where(ssc_)[0].shape[0]
#

#########################
#%% Dataset Pre-processed
#########################

# Constructing the classifier input (X)
# X will be a matrix, containing all 6 features
# is also possible to delete some feature and verify the result
X = np.append(arr=rms, values=zc, axis=1)
X = np.append(arr=X, values=mav, axis=1)
X = np.append(arr=X, values=var, axis=1)
#X = rms # testando somente com rms como entrada
#y = targets # saida = targets
#y = y.reshape(-1,1).astype(float)

# The classifier output (y)
y = np.array(targets_str)

#y = np.zeros((targets.shape[0],6),dtype=bool)

#for n in range(1,7):
#    y[:,n-1] = (targets == n).astype(bool)

############################################
#%% Here we start the Machine Learning Part
###########################################

# Encoding categorical data
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
labelencoder_Y = LabelEncoder()
labelencoder_Y.fit(HAND_MOVIMENTS_NAMES)
y = labelencoder_Y.transform(y)
#onehotencoder = OneHotEncoder(categorical_features = [0])
#y = onehotencoder.fit_transform(y).toarray()

#%%
y = np.zeros((targets.shape[0],6),dtype=bool)

for n in range(6):
    y[:,n] = (targets == n).astype(bool)

#%% Splitting the dataset into the Training set and Test set
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)

# Feature Scaling
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

#%% Finalmente montando a rede neural
#%% Importing the Keras libraries and packages
import keras
from keras.models import Sequential
from keras.layers import Dense

# Initialising the ANN
classifier = Sequential()

# Adding the layers
# Adding the input layer and the first hidden layer
# 4 entradas RMS_ch1, RMS_ch2, RMS_ch3, RMS_ch4
classifier.add(Dense(output_dim = 29, init = 'uniform', activation = 'relu', input_dim = 16))
# Adding the second hidden layer
classifier.add(Dense(output_dim = 13, init = 'uniform', activation = 'relu'))
# Adding the output layer
classifier.add(Dense(output_dim = 6, init = 'uniform', activation = 'sigmoid'))

# Compiling the ANN
classifier.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])

#%% Fitting the ANN to the Training set
classifier.fit(X_train, y_train, batch_size = 10, nb_epoch = 100, verbose=1)

#%% Making the predictions and evaluating the model

#%% Predicting the Test set results
#y_pred = classifier.predict_classes(X_test)#.reshape(48,1)
y_pred = classifier.predict(X_train,verbose=1)

# confusion matrix
#%%
def get_labeled_matriz(sparce):
    dense = np.zeros((sparce.shape[0],1))
    for i in range(sparce.shape[0]):
        ind = np.where(sparce[i,:] == (sparce[i,:]).max())[0][0]
        dense[i] = ind + 1
    return dense

#%% Making the Confusion Matrix
from sklearn.metrics import confusion_matrix
y_pred_l = get_labeled_matriz(y_pred)
y_test_l = get_labeled_matriz(y_train)
cm = confusion_matrix(y_test_l, y_pred_l)

cole = np.append(arr=y_pred_l, values=y_test_l, axis=1)
#%%
lines = np.zeros((6,1))
columns = np.zeros((1,7))
total_acertos = 0

for i in range(6):
    lines[i,0] = cm[i,i] / np.sum(cm[i,:])
    columns[0,i] = cm[i,i] / np.sum(cm[:,i])
    total_acertos += cm[i,i]

t_acc = total_acertos / np.sum(cm)
columns[0,6] = t_acc
cm2 = np.append(arr=cm, values=lines, axis=1)
cm2 = np.append(arr=cm2, values=columns, axis=0)
